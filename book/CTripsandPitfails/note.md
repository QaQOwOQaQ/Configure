# C陷阱与缺陷

## 第一章 词法陷阱

### 1.0 引子

==符号== 指的是程序的一个基本组成单元，其作用相当于一个句子中的单词，但是同一个单词在不同的句子中意思是基本一样的，而符号可能完全不同。

编译器中负责将程序分解为一个一个符号的部分，一般称为==“词法分析器”==。

例如 ```if （x > big）big = x；```经过词法分析之后，可以写为：

```c
if
(
>
big
)
big
=
x
;
```

### 1.1 =不同于==

在C语言中，之所以使用=作为赋值运算符，==作为比较运算符，主要是因为赋值运算出现的更为频繁，因而字符较少的=就被赋予了更常用的含义—赋值运算。

某些编译器在发现条件判断的条件判断表达式中出现类似于```e1 = e2``` 的赋值语句时会给出警告。但当我们确实需要使用赋值语句时，不应该关闭警告选项，而是显示的进行比较。

例如表达式```if (x = y)```

可以写为：```if ((x = y) != 0)```

### 1.2 &和 | 不同于 &&和 ||

### 1.3 词法分析中的贪心法

C语言划分符号的规则：每一个符号应该包含尽可能多的字符。

例如 ```a---b;```

将会被划分为```(a--) - b;```，而不是```a - (--b);```

### 1.4 整形常量

==八进制（octonary system）==

如果一个整形常量第一个字符是数字0，或者以字符Q结尾，那么该常量将被视作八进制。

所以有时用O结尾，有时用Q结尾，原因：为避免把字母O误认作零，改由Q代替

==十六进制（hexadecimal system）==

0x开头，或者以字符H结尾。

==二进制（binary system）==

以字符B结尾。

==十进制（decimal system）==

开头不能是0，以 字符D结尾。

### 1.5 字符和字符串

C语言中的单引号和双引号的含义迥异。

用单引号引起的一个字符实际上代表一个**整数**，整数值对应于该字符在编译器采用的字符集中的序列值。因此，对于采用 ASCLL 字符集的编译器而言，'a' 的含义与 97（十进制）严格一致。

用双引号引起的字符串，代表的却是一个指向无名数组起始字符的**指针**，该指针被双引号之间的字符以及一个额外的二进制为零的字符 '\0' 初始化。

例如，下面的语句是等价的：

```c
printf ("Hello");

/* 等价于 */

char str[] = {'h', 'e', 'l', 'l', 'o', 0};
printf (str);
```



## 第二章 语法陷阱

### 2.1 理解函数声明

任何 C 变量的声明都由两部分组成：类型以及一组类似表达式的声明符。

**一旦我们知道了如何声明一个给定类型的变量，那么该类型的类型转换符就很容易得到了：只需要把声明中的变量名和声明末尾的分号去掉，再将剩余的部分用一个括号整个“封装”起来即可。**



### 2.2 优先级问题

C 语言运算符优先级表

![img](https://images2015.cnblogs.com/blog/550032/201609/550032-20160927115252031-1960111031.png)

> 单目运算符，赋值运算符，三目运算符自右向左结合。
>
> 任何一个逻辑运算符的优先级比任何一个关系运算符的优先级要低。
>
> 移位运算符的优先级比算术运算符要低，但是比关系运算符要高。
>
> 六个关系运算符的优先级并不相同。因此，如果我们要比较 a 和 b 的大小顺序是否和 c 和 d 的大小顺序一样，可以这样写：```a < b == c < d```
>
> 任意两个逻辑运算符的具有不同的优先级，所有的按位运算符优先级（& , | , ^）要比顺序运算符（&&， ||）的优先级高；每个与运算的优先级比或运算的优先级高，异或运算的优先级介于两者之间。
>
> 三目运算符的优先级最低，这样我们就可以在三目运算符的条件表达式中包含关系运算符的逻辑组合。例如：```tax_rate = income > 4000 && residency < 5 ? 3.5 : 2.0;``` 本例其实还说明赋值运算符的优先级低于条件运算符的优先级是有意义的。





C++ 运算符优先级和结合性

| 优先级           | 运算符                                         | 说明                      | 结合性   |
| :--------------- | ---------------------------------------------- | ------------------------- | -------- |
| 1                | ::                                             | 范围解析                  | 自左向右 |
| 2                | ++  --                                         | 后缀自增/后缀自减         |          |
| ()               | 括号                                           |                           |          |
| []               | 数组下标                                       |                           |          |
| .                | 成员选择（对象）                               |                           |          |
| −>               | 成员选择（指针）                               |                           |          |
| 3                | ++  --                                         | 前缀自增/前缀自减         | 自右向左 |
| +  −             | 正/负号                                        |                           |          |
| !  ~             | 逻辑非/按位取反                                |                           |          |
| (type)           | 强制类型转换                                   |                           |          |
| *                | 取指针指向的值                                 |                           |          |
| &                | 某某的地址                                     |                           |          |
| sizeof           | 某某的大小                                     |                           |          |
| new, new[]       | 动态内存分配/动态数组内存分配                  |                           |          |
| delete, delete[] | 动态内存释放/动态数组内存释放                  |                           |          |
| 4                | .*  ->*                                        | 成员对象选择/成员指针选择 | 自左向右 |
| 5                | *  /  %                                        | 乘法/除法/取余            |          |
| 6                | +  −                                           | 加号/减号                 |          |
| 7                | <<  >>                                         | 位左移/位右移             |          |
| 8                | <  <=                                          | 小于/小于等于             |          |
| >  >=            | 大于/大于等于                                  |                           |          |
| 9                | ==  !=                                         | 等于/不等于               |          |
| 10               | &                                              | 按位与                    |          |
| 11               | ^                                              | 按位异或                  |          |
| 12               | \|                                             | 按位或                    |          |
| 13               | &&                                             | 与运算                    |          |
| 14               | \|\|                                           | 或运算                    |          |
| 15               | ?:                                             | 三目运算符                | 自右向左 |
| 16               | =                                              | 赋值                      |          |
| +=  −=           | 相加后赋值/相减后赋值                          |                           |          |
| *=  /=  %=       | 相乘后赋值/相除后赋值/取余后赋值               |                           |          |
| <<=  >>=         | 位左移赋值/位右移赋值                          |                           |          |
| &=  ^=  \|=      | 位与运算后赋值/位异或运算后赋值/位或运算后赋值 |                           |          |
| 17               | throw                                          | 抛出异常                  |          |
| 18               | ,                                              | 逗号                      | 自左向右 |



### 2.3 注意作为语句结束标志的分号

例子1：

```c
if (x > 10);
    x = 0;
```

在 if 的后面，我们多加了一个分号，上述语句就相当于：

```c
x = 0;
```

例子2：

```c
if (x > 10)
    return 
a = 1;
b = 2;
c = 3
```

在 return 的后面，我们遗漏了分号，但是不会报错，上述语句就相当于：

```c
if (x > 10)
	return a = 1;
b = 2;
c = 3;
```



### 2.4 switch 语句

**由 switch 控制的流程在执行第一个 case 之后，会自然而然的顺序执行下去**，C 语言的这种特性，既是它的优势所在，也是它的劣势。

因为程序员可能会遗漏 break 语句，而有时候，我们或许需要故意省略 break 语句来实现某种效果。



### 2.5 函数调用

与其他程序设计语言不同，C 语言要求：**在函数调用时，即使函数不带参数，也应该包括参数列表。**

因此，如果 f 是一个函数，那么```f();```是一个函数调用语句，而```f```却是一个什么也不做的语句。更准确的说，它计算函数 f 的地址，却并不调用这个函数。



### 2.6 悬挂 else 引发的额问题

C 语言有这样的规则：**else 始终与同一括号内最近的未匹配的 if 结合。**

例如下面的例子：

```c
if (x == 0)
	if (y == 0)	error();
else z = x + y;

// 上面代码，看起来像是：
if (x == 0) 
{
    if(y == 0)	error();
}
else 
{
    z = x + y;
}

// 实际上是：
if(x == 0) 
{
    if(y == 0)	error();
    else		z = x + y;
}
```



## 第三章 语义陷阱

### 3.1 指针与数组

C 语言中的数组值得注意的地方有以下两点：

1. C 语言中只有一维数组，并且数组的大小必须在编译器就作为一个常数确定下来。所谓多维数组其实就是数组的元素可以是任意类型的对象，包括数组。
2. 对于一个数组，我们能做的只有两件事：确定该数组的大小以及获得指向该数组下标为 0 的指针。有关数组的其他操作，哪怕他们乍看上去是以数组下标进行运算的，实际上都是通过指针进行的。换言之，任何一个数组下标运算都等同于一个对应的指针运算，因此我们完全可以根据指针行为定义数组下标的行为。



_____



```c++
int a[3] = {1, 2, 3};
int *p = &a;
```

这种写法在 ANSI C 中是非法的，以为 ```&a``` 是一个指向数组的指针，而 ```p``` 是一个指向整型变量的对象，它们的类型不匹配。

正确的写法应该是：

```c++
int a[3] = {1, 2, 3};
int *p = a;
```

这里的 ```a``` 就是 ```a[0]``` 的地址。

**除了 ```a``` 被用作运算符 ```sizeof``` 的参数这一情形，在其他所有情形中使用数组名 ```a``` 都代表指向数组 ```a``` 中下标为 ```0```  的元素的指针**。

另外，在上文中我们说过“有关数组的其他操作，哪怕他们乍看上去是以数组下标进行运算的，实际上都是通过指针进行的。”

例如 ```a[i]``` 表示取数组 ```a``` 下标为 ```i``` 的元素的值，它实际表示的是： ```*(a + i)```，只不过这种写法非常常用，因此被简记为 ```a[i]```。实际上，由于 ```a + i``` 和 ```i + a``` 一样，因此 ```a[i]``` 和 ```i[a]``` 具有相同的含义。(也许某些汇编程序员会觉得很熟悉--偏移量)

----

```c++
#include <iostream>
using namespace std;
int main()
{
    int a[3][3] = {
      {1, 2, 3}, {4, 5, 6}, {7, 8, 9},
    };
    
    int (*p)[3];
    for(p = a; p < &a[3]; p ++ ) {
        int *j;
        for(j = *p; j < &(*p)[3]; j ++ ) 
            cout << *j << ' ';
        cout << endl;
    }
    
    return 0;
}
```

**对指针的 *(解引用) 可以理解为让指针指向某个地方。** 



### 3.2 非数组的指针

在 C 语言中，**字符串常量**代表了一块包括字符串中所有字符以及一个空字符 ```'\0'``` 的内存区域的地址。

如果我们想要拼接两个字符串 s 和 t，正确的写法为：

```c
#include <stdio.h>
#include <stdlib.h>
#include <string.h>

int main()
{
    char *s = "Hello,";
    char *t = "World!";
    char *r;
    r = malloc(strlen(s) + strlen(t) + 1);
    if(!r) {
        puts("分配失败");
        exit(1);
    }
    strcpy(r, s);
    puts(r);
    strcat(r, t);
    puts(r);
    
    
    return 0;
}
```



### 3.3 作为参数的数组声明 

在 C 语言中，我们无法将一个数组作为函数参数直接传递。如果我们将数组名作为参数，那么数组会立即被转换为指向该数组第一个元素的指针。

例如：

```C
#include <stdio.h>
#include <string.h>

int main()
{
    char *s = "Hello!";
    puts(s);
    puts(&s[0]);
    // 传递一个数组名和传递数组第一个元素的地址是等价的
    return 0;
}
```

因此，将数组作为函数参数毫无意义。所以，C 语言会自动将作为参数的数组声明转换为对应的指针声明。

例如：

```C
int strlen(char s[]) {
	/* do something */
}
```

与下面的写法完全相同：

```c
int strlen(char *s) {
	/* do something */
}
```



### 3.4 避免“举隅法”

**举隅(yu2)法**：举一端为例。意在使人由此一端而推知其他。意在以更宽泛的词语来代替含义相对较窄的词语，或者相反：例如，以整体代表部分，或者以部分代表整体。

C 语言中一个常见的陷阱：混淆指针与指针所指向的数据。

例如：

```C
char *p, *q;
p = "xyz";
```

尽管有时候我们不妨认为，上面的赋值语句使得 ```p``` 的值就是字符串 ```"xyz"``` ，然而实际情况并不是这样。实际上， ```p``` 的值是一个指向由 ```'x', 'y', 'z', '\0'``` 四个字符组成的数组的起始元素的指针。

因此，如果我们执行下面语句：

```p = q;```

```p``` 和 ```q``` 现在是指向内存中同一个地址的指针。这个赋值语句并没有复制内存中的字符。需要记住的是，复制指针并不同时复制指针所指向的数据。



### 3.5 空指针并非空字符串

在 C 语言中，编译器保证由 0 转换而来的指针并不等同与任何有效的指针。出于代码文档化的考虑，常数 0 这一个值常用一个符号来代替：

```#define NULL 0```

当常数 0 被转换为指针使用时，这个指针绝对不能被解除引用。换句话说，我们绝对不能企图用该指针所指向的内存中存储的内容。

### 3.6 边界计算与不对称边界

在所有常见的程序设计错误中，最难于察觉的一类是**“栏杆错误”**，也常被称为“差一错误”。典型的例子是：100 米长的围栏每隔 10 米 需要提跟支撑用的围栏，则总共需要多少根围栏？如果不假思索，最“显而易见”的答案是将 100 除以 10，得到的答案是 10，即需要 10 根栏杆。当然这个答案是错误的，正确答案是 11。

也即，得出正确答案的最容易方式是这样考虑：要支撑 10 米长的围栏实际需要两根栏杆，两段各一根。这个问题的另一种考虑方式是：除了最右侧的一段围栏，其他每一段 10 米长的围栏都只在左侧有一根围栏；而例外的最右侧不仅左侧有一根围栏，右侧也有一根围栏。

前面一段讨论了解决问题的两种方法，实际上提示了我们**避免“栏杆错误”的两个通用原则：**

1.  首先考虑最简单情况下的特例，然后将得到的结果外推，这是原则一。
2.  仔细计算边界，绝不掉以轻心，这是原则二。

将上面总结的两个原则牢记于心之后，来看一个典型的例子：计算整数范围的边界。例如，假设整数 x 的边界条件为 x>=16 且 x<=27，那么此范围内 x 的可能取值个数有多少？

根据原则一，我们考虑最简单情况下的特例：x>=16 且 x<=16，此时显然只有一个元素，也即上边界和下边界重合时，此范围内满足条件的整数只有一个。因此答案就是 27-16+1=12。

然而有时稍不留意，我们会想当然的认为答案为：27-16=11个整数 ，那么是否存在一些编程技巧，可以降低这类错误发生的可能性呢？

这个编程技巧不但存在，而且可以一言以蔽之：**用第一个入界点和第一个出界点来表示一个数值范围**。具体而言，对于上面的例子我们不应该说整数 x 的边界条件为 x>=16 且 x<=27，而应该说整数 x 的边界条件为 x>=16 且 x<28。注意，这里下界 16 是“入界点”，包含在取值范围之中；而上界是“出界点”，即不包含在取值范围之中，这种不对称或许从数学上而言并不优美，但是它对于程序设计的简化效果却令人吃惊。

1. 取值范围的大小就是上界与下界之差。28-16的值恰好是12。
2. 如果取值范围为空，那么上界等于下界。
3. 即是取值范围为空，上界也永远不可能小于下界。

对于像 C 语言这样数组下标从 0 开始的语言，不对称的边界给程序设计带来的便利要更加明显：这种数组的上界（即第一个“出界点”）恰好是数组元素的个数。

另一种考虑不对称边界的方式是，把上界视作某序列中第一个被占用的元素，而把下界视作序列中第一个被释放的元素。当处理各种不同类型的缓冲区时，这种看待问题的方式特别有用。



### 3.7 求值顺序

C 语言中只有 4 个运算符（&&、||、 ?: 和 ,）存在规定的求值顺序。运算符 && 和 || 先对左侧操作数求值，只在需要的时候才对右侧操作数求值。运算符 ?: 有三个操作数：在 a?b:c 中，操作数 a 首先被求值，根据 a 的值再去求操作数 b 或 c 的值。逗号运算符首先对左侧操作数求值，然后“丢弃”该值，再对右侧操作数求值。

> 注：分隔函数参数的逗号并非逗号运算符，例如，x 和 y 在函数 f(x, y) 中的求值顺序是未定义的，而在函数 g((x, y)) 中却是确定的先 x 后 y的顺序。  
>
> 在后一个例子中，函数 g 只有一个参数。这个参数的值是这样求得的：先对 x 求值，然后“丢弃” x 的值，接下来求 y 的值。因此最后的值永远是 y。

C 语言中其它所有运算符对齐操作数求值的顺序是未定义的，特别是，赋值运算符并不保证任何求值顺序。另外，运算符 && 和 || 对于保证检查操作按照正确的顺序执行至关重要，在语句``if(y != 0 && x / y > tolerate)`` 中，就必须保证 y 非 0 时才能执行 x/y 的操作。

下面这种从数组 x 中复制前 n 个元素到数组 y 中的做法是不正确的，它对求值顺序做了太多假设：

```C
i = 0;
while(i < n) {
    y[i] = x[i ++ ];
}
```

我们假设 ```y[i] = x[i ++ ];``` 执行的是：

```C
y[i] = x[i];
i ++ ;
```

但也有可能是：

```C
y[i + 1] = x[i];
i ++ ;
```

之所以会出现后面的情况是因为 ```y[i]``` 的地址将有可能在 ```i``` 自增之后被求值。而我们假设 ```y[i]``` 的地址在 ```i``` 自增之前被求值。



### 3.8 操作符 &&、|| 和 ！

不要把 && 和 & 混淆，以及 || 和 | 混淆。它们一类是逻辑运算符，一类是按位运算符。尽管有时候用错了可能也会得到理想的结果。

### 3.9 整数溢出

C 语言中有两倍整数算术运算：有符号运算和无符号运算。在无符号算术运算中，没有所谓“溢出”一说：所有无符号数运算都以 2 的 n 次方为模，这里 n 是结果中的位数。

溢出的结果是未定义的，有时候会简单的利用符号来判断是否溢出，例如两个正数相加结果如果是负数那么肯定溢出，但是溢出不一定就是负数。



### 3.10 为 main 函数提供返回值

对于一个函数而言，如果没有显式声明返回类型，那么函数返回类型就默认为整形。但是这个程序并没有给出任何返回值。



## 第四章 链接
### 4.1 什么是链接器
C 语言的一个重要思想就是分别编译，即若干个源程序可以在不同的时候单独进行编译，然后在恰当的时候整合到一起。
## 第五章 库函数
## 第六章 预处理器
## 第七章 可移植性缺陷
