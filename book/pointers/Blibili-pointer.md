

# 一、Harsha Suryanarayana

## 1. 指针简介

### 1.1 指针的声明

指针的标准写法：```type* p;```	
常见的不标准的写法：```type *p = &a;```

> 在不标准的写法中，我们常常会把 解引用符号（*）与变量名联系在一起，这就导致了一些直观上的不舒服？。
>
> 例如代码：```int *p = &a;``` 我们会自觉的把等号左边分成两个部分，类型和变量名，如果把 ```*``` 和变量名连在一起，那么看上去就好像是把 ```a``` 的地址放到了```*p``` 里面，而类型也变成了 ```int``` 而不是 ```int*```。
>
> 但如果我们写成：```int* p = &a;``` 这样看起来就很舒服了，```a``` 的地址存放在了指针变量 ```p``` 中，```p``` 它就是一个变量，它存储的是 ```a``` 的地址，而 ```*p``` 表示解引用指针变量 ```p``` 里面的地址，得到该地址存放的值。

所以说，推荐写成标准的形式，看起来更舒服！

### 1.2 指针的常识

1. **指针是不占用内存空间的**，其本身是地址，地址怎么会占内存空间。**指针变量才占用内存空间。**
2. 当我们仅使用数组名时，返回的是**数组首元素的地址**。
2. 函数用来指向或引用内存中的数据（变量或常量）。
2. 指针是由地址的，指针的地址不等同于指针变量的地址。

### 1.3 指针的算术运算

指针变量+/-1：这里的1是指针类型的长度，而不是数字 1  

Code:

```c++
int a = 1;
int* p = &a;
cout << p << endl; 	   // -> x
cout << (p + 1) << endl;  // -> x + sizeof(int)
```



## 2. 输出char类型的地址

在C++中，如果cout一个字符数组的话，那么它会沿着这个地址，一直输出这个字符串，直到遇到'\0',例如：

```c++
char*c = "hello";
cout << c << endl;

输出的结果是：hello
```

如果我们自作聪明的想输出第一个字符的地址，例如这样输出：

``` cout << &c[0] << endl;```

不幸的是，这样输出的结果依旧不是我们需要的地址。实际上输出结果仍然是整个字符串。

但是，如果我们回归到C语言的话，例如用printf的话，如下：

 ```printf("%x\n", &c[0]);```

幸福的事情发生了，输出的结果是：

``` 46f020```

的确是字符串的首地址，但是，如果我们要输出字符串的地址，难道就这一种方法吗？难道我们就不可以用我们C++上的cout达到我们的效果吗？

**原因：*****c是靠%s, %x, %p来区分指针表达式&a[0]的输出形式的；c++没有这个格式控制，只能按一种形式输出，对char*类型的指针值就理解为串输出，所以必须对这个指针表达式做类型转换处理。**

例如：

```c++
char c='a';
cout << "&c:" << &c << endl;

输出的仍然不是字符变量c的地址，而是乱码。
```



在C++中，字符串是以空终止符（'/0'）结尾的字符数组，通过字符串中第一个字符的指针访问字符串。也就是说，字符串的值是字符串中第一个字符的（常量）地址。如下的面3种形式表示：

```c++
char *str1  = "string1";
char str2[] = "string2";
char str3[] = {'s','t','r','i','n','g','3','\0'};

cout << "line 1:str1=" << str1 << endl;
cout << "line 2:str2=" << str2 << endl;
cout << "line 3:str3=" << str3 << endl;

Output:
line 1:str  = string1
line 2:str2 = string2
line 3:str3 = string3
```

运行可知，这3行的输出就是保存的字符串的值，而并非我们认为的地址。那么，我们可以联系到前面&c，其实这就是一个char *的变量，所以，输出的自然就应该是字符串的值。可是，&c保存的字符串是没有终止符的，因此输出的也就是乱码了。

最近，在读到《C++程序设计教程》（第4版）第12章的时候，我才解决了这个疑惑。实际上，**C++标准库中I/O类对输出操作符<<重载，在遇到字符型指针时会将其当做字符串名来处理，输出指针所指的字符串。既然这样，我们就别让他知道那是字符型指针，所以得进行类型转换，即：希望任何字符型的指针变量输出为地址的话，都要作一个转换，即强制char *转换成void *，**如下所示：

```c++
cout<<"static_cast<void *>(&c)="<<static_cast<void*>(&c)<<endl;

cout<<"static_cast<void *>(str)="<<static_cast<void*>(str)<<endl;
```

此时，可以看到输出的结果就是char类型变量和字符串变量的地址了。



## 3. 为什么指针要使用强类型

### 3.1 强类型语言和弱类型语言

**强类型语言是一种强制类型定义的语言，即一旦某一个变量被定义类型，如果不经强制转换，那么它永远就是该数据类型。而弱类型语言是一种弱类型定义的语言，某一个变量被定义类型，该变量可以根据环境变化自动进行转换，不需要经过现行强制转换。**

其中

强类型语言包括：Java、.net、Python、C++等语言。其中Python是动态语言，是强类型定义语言，是类型安全的语言，Java是静态语言，是强类型定义语言，也是；类型安全的语言；

弱类型语言包括：VB，PHP，JavaScript等语言。其中VBScript是动态语言，是一种类型不安全的原因。

**举个栗子吧：**

```vb.net
var A=5;
var B="5"
sumA=A+B;
sumB=A-B;
```

**sumA=55,系统默认+字符连接符，将A转化为字符串类型；而sumB=0；系统认为-是算数运算符，从而将B转化为int类型，所以sum为5-5=0；**

*上面就是一个弱类型语言的例子；*

------

*那么强类型语言与弱类型语言有什么优缺点呢？*

**强类型语言和弱类型原因其判断的根本是是否会隐形进行语言类型转变。强类型原因在速度上可能略逊于弱类型语言，但是强类型定义语带来的严谨性又避免了不必要的错误。**

上面提到了动态语言与静态语言，那就讲讲动态语言静态语言的区别：

**动态类型语言：动态性语言是指在运行期间才去做数据类型检查的语言，也就是说动态类型语言编程时，永远不用给任何变量指定数据类型，该语言会在第一次赋值给变量时，在内部将数据类型记录下来。Python和Ruby就是一种典型的动态类型语言，其他的各种脚本语言如VBScript也多少属于动态类型语言。**

**静态类型语言：静态类型语言与动态类则刚好相反，它的数据类型在编译期间检查，也就是说在写程序时要声明所有变量的数据类型，C/C++是静态类型语言的典型代表，其他静态语言还有C#、Java等。**

对于动态语言与静态语言的区分，其根本在**于判断是在运行期间去做数据类型还是在编译期间检查。**

### 3.2 指针为什么要使用强类型

Q：指针保存的地址的类型都是一样的，为什么还要为指针指定类型呢？

A：我们使用指针不仅仅只是用到地址，还需要经常解引用(*)来获得指针所指向地址的值或者写数据，因此我们就需要知道两个信息：①我们需要获得多少字节的内容；②采用何种方式解析数据。例如：char占用1字节，int占用4字节，他们占用字节大小是不一样的，float也占用 4字节，但是float和int的解析方式是不一样的。

Eg：**指针变量保存的地址是首地址**



## 4. 通用指针类型（void *）





## 5. 指向指针的指针

理解多重指针的最好方法是**画图**。

如果我们让一个指针指向一片内存，那么就在指针和内存之间加上一个箭头，表示指针指向内存。假设有指针p指向内存s，那么*p就可以在图中表示为由p沿着指向s的指针到s，这样多重指针不过就是多走几次罢了。

Code：

```c++
int x = 10;
int* p= &x;
int** q = &p;
int*** r = &q;
```

对面上面的代码，表现在图形中就是：

![IMAGE](https://i.bmp.ovh/imgs/2022/07/14/ec141bc6c035f827.png)





## 6. 传值调用

Code：

```c++
void Increamet(int x)
{
    x = x + 1;
}
int main()
{
    int a = 10;
    Increment(a);
}
```

在上面的代码中，main中的a是实参，Increment中的x是形参，传值调用的过程就是实参映射到实参，也就是将实参的值拷贝到形参中。





## 7. 数组与指针

Code：

```c++
int a[3] = {1, 2, 3};
cout << &a[i] << endl; 	// <==> cout << (a + i) << endl;
cout << a[i] << endl;	// <==> cout << *(a + i) << endl;

int *p = a;
*p ++ ; // valid
a ++ ;	// invalid
```

**指针就是数组，数组就是指针**

数组的基地址就是数组首元素的地址，直接使用数组名就可以得到数组的基地址

## 8. 数组作为函数参数

### 8.1 例1

Code：

```c++
#include <iostream>
using namespace std;

int getSum(int t[]) // <==> int getSum(int *t)
{ 
    int sum = 0;
    int Size = sizeof(t) / sizeof(t[0]);
    
    cout << "size-t : " << sizeof(t) << endl;
    cout << "getSum-size: " << Size << endl;
    for(int i = 0; i < Size; i ++ ) sum += t[i];
    
    return sum;        
}

int main()
{   
    int a[] = {1, 2, 3, 4, 5};
    int Size = sizeof(a) / sizeof(a[0]);
    
    cout << "size-a: " << sizeof(a) << endl;
    cout << "main-size: " << Size << endl;

    int sum = getSum(a);
    cout << "sum: " << sum << endl;

    return 0;
}
```

Output：

```c++
size-a: 20
main-size: 5
size-t : 8
getSum-size: 2
sum: 3
```

Explaion：

> 在上面的程序中，我们希望将数组 a 传递给函数 getSum 来求得数组 a 中所有元素的和（15）。
>
> 我们通过一个巧妙的方法得到数组 a 中元素的个数：sizeof(a) / sizeof(a[0]);
>
> sizeof(a) 是数组 a 所占用的字节数，同理如果有一个 int 类型变量 i，那么 sizeof(i) = 4；sizeof(a[0]) 是数组 a 中一个元素占用的字节数。
>
> 在 main 函数中我们正确求得了 数组 a 的元素个数（5），数组 a 占用的字节数（20），然而当我们把数组 a 传递给函数 getSum 时，我们在函数内求得数组 a 的元素个数为 2，并且数组 a 占用的字节大小为 8，而不是 20 (5*sizeof(int))。
>
> 这是为什么呢？



### 8.2 例2

Code：

```c++
#include <iostream>
using namespace std;

void change(int t[], int n)
{
    for(int i = 0; i < n; i ++ )
        t[i] = t[i] * 2;
}
int main()
{
    int a[5] = {1, 2, 3, 4, 5};
 
    cout << "before change: ";
    for(int i = 0; i < 5; i ++ )    cout << a[i] << ' ';
    cout << endl;
    
    change(a, 5);
    
    cout << "after change: ";
    for(int i = 0; i < 5; i ++ )    cout << a[i] << ' ';
    cout << endl;
    
    return 0;
}
```

Output：

```
before change: 1 2 3 4 5 
after change: 2 4 6 8 10 
```

Explain：

> 我们发现，将数组 a 传递给函数 change 之后，在 change 中执行的操作返回到了实参中。
>
> 这说明数组的传递是传引用而不是传值。



### 8.3 例3

Code：

```c++
#include <iostream>
using namespace std;

void out(int t[])
{
    cout << "&t: " << &t << endl;
    cout << "t: " << t << endl;
    cout << "*t: " << *t << endl;
}
int main()
{
    int a[5] = {1, 2, 3, 4, 5};
    cout << "&a: " << &a << endl;
    cout << "a: " << a << endl;
    cout << "*a: " << *a << endl;
    
    out(a);

    return 0;
}
```

Output：

```
&a: 0x7fff33a6e2d0
a: 0x7fff33a6e2d0
*a: 1
&t: 0x7fff33a6e2b8
t: 0x7fff33a6e2d0
*t: 1
```

Explain：

> 我们发现，将数组 a 传递给函数 out 之后，数组 t 的首地址和数组 a 的首地址是一样的，但是在数组中，理应来说 &t 和 t 的结果应该是一样的，例如在 main中 &a 和 a 的结果就是一致的，但实际上打印出来的结果是不同的，这又是为什么呢？





### 8.4 例4

Code：

```
#include <iostream>
using namespace std;

void out(int *t)
{
    cout << "&t: " << &t << endl;
    cout << "t: " << t << endl;
    cout << "*t: " << *t << endl;
    for(int i = 0; i < 5; i ++ )
        printf("&(t + %d)[%p] = %d\n", i, t + i, *(t + i));
}
int main()
{
    int a[5] = {1, 2, 3, 4, 5};
    cout << "&a: " << &a << endl;
    cout << "a: " << a << endl;
    cout << "*a: " << *a << endl;
    
    out(a);

    return 0;
}
```



Output：

```
&a: 0x7fff9a681e00
a: 0x7fff9a681e00
*a: 1
&t: 0x7fff9a681dd8
t: 0x7fff9a681e00
*t: 1
&(t + 0)[0x7fff9a681e00] = 1
&(t + 1)[0x7fff9a681e04] = 2
&(t + 2)[0x7fff9a681e08] = 3
&(t + 3)[0x7fff9a681e0c] = 4
&(t + 4)[0x7fff9a681e10] = 5
```

Explain：

> 我们发现，将数组 a 传递给函数 out，out 的形参是一个 int 型指针，依然可以遍历数组。

### 8.5 总结

1. 由例4和例2可得出： **type function(int a[]) <==> type function(int *a)**，当我们把一个数组作为参数传递给函数时，并不会传递整个数组的内容，而是仅仅传递数组的首地址。同时这也印证了那句话：**数组就是指针，指针就是数组**
2. 由结论1，对于数组来说，不使用传值方式，总是**传引用**。因为有时候数组可能很大，拷贝整个数组没有太大意义，它会耗费大量内存。
3. 由结论2，我们便可以知道为什么例3中，在函数 out 中打印 &t 和 t是不一样结果了，因为编译器把 int t[] 转换成了 int *t，因此 t 本质上不是一个数组，而是一个指向数组的指针。所以在栈中，只会申请 8 字节（64位机器一个指针占用的内存空间）空间，用来存放这个指针 t，所以说&t 实际上打印的是在栈中 t 的地址，而 t 则打印的是指针变量 t 的内容，也就是它指向的地址（即数组 a 的地址）。
4. 由2和3，也就解释了例1 中为什么在函数 getSum中，sizeof(t) = 8，因为我们传递过去的不是一个完整的数组，而是指向这个数组的指针。





## 9. 指针和字符数组

——当我们在 C 语言中谈论字符数组时，基本上就是在讨论字符串

### 9.1如何把字符串存入字符数组

——首要的需求就是字符数组必须足够大，大到能够容纳字符串

一个足够大的字符数组是指它的大小>=字符的数量 +1，因为在字符串中必须指明结束标志（\0），但整型和浮点型数组没有结束符， 完全要自己严格控制元素的数量。

### 9.2 字符数组的声明

Code：

```c++
#include <iostream>
#include <cstring>

using namespace std;

int main()
{
    char s[] = "john"; // 用双引号给字符数组复制，编译器会自动给字符串添加结束标志'\0'，因为字符数组的长度就是字符串长度+1（\0）
    cout << sizeof(s) << endl; // 5，  包含'\0'
    cout << strlen(s) << endl; // 4，不包含 '\0'
    
    char a[] = {'1', '2', '3', '4'}; // 需要手动添加结束标志，这里因为没有添加 '\0'，strlen(a)出错
    cout << sizeof(a) << endl; 	// 4
    cout << strlen(a) << endl;  // 8，出错
    
    char b[] = {'1', '2', '\0'}; 	// 手动添加'\0'
    cout << sizeof(b) << endl;  // 3
    cout << strlen(b) << endl;	// 2
    
    return 0;
}
```

Tips：

```c++
char s[] = "john";
// 不可以写为下面的形式：
char s[107];
s = "john";
// 用双引号初始化必须在同一行

// 其次，下面的声明方式是不严谨的，因为我们不知道字符串的结束在那
// 因此，可能发生奇怪的问题
char a[] = {'1', '2', '3', '4'};

// 例如下面：
#include <iostream>
#include <cstring>
using namespace std;
int main()
{
    char a[] = {'1', '2', '3', '4'};
    char *s = a;
    cout << a << endl;
    cout << s << endl;
    return 0;
}

// 输出：
1234t��M�
1234t��M�
    
// 可以发现出现了乱码    
```



### 9.3  char *

Code：
```c++
#include <iostream>
#include <cstring>
using namespace std;
int main()
{
    char *s = "Hello";
    s[0] = 'A';
    return 0;
}
```

Explain：

> 上面的代码会报错，因此把  "Hello" 的值----也就是**字符串常量字面值**，也就是 "Hello" 的地址，准确来说是起始地址----赋给字符指针 str，Linux下 "Hello"字符串常量是存放于**只读数据区**（常量区）的，不可以修改。
>
> 因此如果我们要把 char* 传递到函数中，那么形参的类型最好是 const char*
>
> 对于 ```char s[] = "Hello"; ```
>
> s[] 是一个字符数组，编译器首先在栈中分配一定的连续空间用于存放 “Hello” 中的字符以及结尾符，然后把字符串常量的内容，也就是
> "Hello" 中的各个字符和结尾符复制到这个**栈**中的连续空间中。str是数组名，用来表示这个连续栈空间的起始地址，所以str中存放的是栈地址，这个地址的数据是可写的。
>
> **在 Linux 中，堆，全局数据，常量等都是存放于从 0x8048000 开始的内存地址，向上增长。一般来说，32位机器上，在Linux中，栈地址空间从3G（0xbfffffff）开始向下增长。**



Tips：

```c++
#include <iostream>
#include <cstring>
using namespace std;
int main()
{
    char ch[] = "Hello";
    char *s = ch;
    s ++ ;
    cout << s << endl;	//ello
    s[0] = 'X';
    cout << s << endl;	// Xllo
    return 0;
}
```

由于 ```char*s = ch;```中的 ch 不是字符串常量，因此 s 可以修改。





## 10. 指针和二维数组

多维数组本质上是**数组的数组**，由于一个指针可以表示一个数组，因此可以把二维数组看做一维指针数组。

**数组**可以看做是同类事物的集合，**多维数组**基本上可以理解为数组的集合。

例如二维数组```A[3][2]```，如下图所示：

![](https://s1.328888.xyz/2022/07/14/LtB4I.png)

> 对 A 解引用就可以得到 A[0], A[1], A[2]
>
> 对 A[i] 解引用就可以得到 A[i]\[0\], A[i]\[1\]
>
> 对 A[i]\[j\] 解引用就可以得到具体的值
>
> **注意别把指针数组和二维指针搞混了，根本不是一回事！**

### 10.1 二维数组在内存中的存放方式

假设我们生成了一个数组 ```A[3][2]```

![IMAGE](https://i.bmp.ovh/imgs/2022/07/14/2e64b6aa12631e70.png)

此时如果我们定义一个指针 ```int *p = &A;``` 会编译错误，因为这里的 int 类型指针 p 指向了一个一维数组，这与指针的类型不匹配。

### 10.2 二维数组的运算

Code：

```c++
#include <iostream>
#include <cstring>

using namespace std;

int main()
{
    int b[2][3] = {
        {2, 3, 6},
        {4, 5, 8}
    };
    
    cout << "二维数组b的首地址: " << &b << endl;
    
    int (*p)[3] = b; // 一维指针数组
    
    // b是二维数组b[][]的数组名,它的地址就是首地址b[0]
    cout << b     << ' ' << b[0] << endl; 
    cout << b + 1 << ' ' << b[1] << endl;
    
    // b <==> &b，b[i] <==> &b[i]
    
    // 对b直接解引用得到的是b[0]，b[0]是一维数组b[0]的数组名，因此b[0]的地址就是首地址b[0][0]
    cout << *b       << ' ' << b[0] << ' ' << &b[0][0] << endl; // *b = *(b + 0)
    cout << *(b + 1) << ' ' << b[1] << ' ' << &b[1][0] << endl;
    
    // 
    cout << *(b + 1) + 2 << ' ' << b[1] + 2 << ' ' << &b[1][2] << endl;
    
    // 
    cout << *(*b + 1) << endl;
    
    
    return 0;
}
```

 Output：

```
二维数组b的首地址: 0x7fff0e673980
0x7fff0e673980 0x7fff0e673980
0x7fff0e67398c 0x7fff0e67398c
0x7fff0e673980 0x7fff0e673980 0x7fff0e673980
0x7fff0e67398c 0x7fff0e67398c 0x7fff0e67398c
0x7fff0e673994 0x7fff0e673994 0x7fff0e673994
3
```

Tips：

> 在二维数组中，有以下两条等式
>
> **取地址：**```&b[i][j] <=> b[i] + j <=> *(b + i) + j```
>
> **取值：**    ```b[i][j] <==> *(b[i] + j ) <==> *(*(b + i) + j)```



## 11. 指针和多维数组

### 11.1 指针和三维数组

Code：

要注意解引用运算符(*)的优先级

```c++
#include <iostream>
using namespace std;
int main()
{
    int c[2][2][2] = {1,2,3,4,5,6,7,8};
    int (*p)[2][2] = c;
    //int *p[2][2] = c; // Wrong!
    return 0;
}
```

Tips：

```c++
c[i][j][k] 
	= *(c[i][j] + k) 
	= *(*(c[i] + j) + k) 
	= *(*(*(c + i) + j) + k)
```

对于上面的转换，只需要牢记指针和数组之间的转换就可以了：

```c++
c[i] = *(c + i);
&c[i] = c + i;
```



### 11.2 多维数组作为参数传递给函数

我们在第 8 章中已经知道，将数组作为参数传递给函数时，实际上不会拷贝整个数组，只会以指针的形式传它的引用。例如：

Code：

```c++
void func(int a[]) {
}
// 等价于
void fundc(int *a) {
    
}
```

上面的例子是一维数组的情况，那么如果传递的是多维数组呢？

Code：

```c++
int c[2][3];
int d[10][10];
void func1(int a[][])  { 	// test 1
}
void func2(int *a)     { 	// test 2
}
void func3(int a[][3]) { 	// test 3  
}
void func4(int *a[3])  { 	// test 4
}
void func5(int **a)    {	// test 5
}
```

Explain：

> 在第一种形式中，编译器会报错，因为我们执行了一个二维数组作为形参，形式上虽然是 ```a[][]```，但编译器会将其转化为  ```(*a)[]```, 也就是说，我们指定了一个指针数组作为参数，但我们没有指定这个指针数组的大小，因此编译器报错。 
>
> 在第二种形式中，编译时不会报错，但如果我们将数组 ```c``` 作为参数执行 ```func()``` 函数，编译器会报错，因为 ```c[][]``` 的类型为 ```(int *)[]```，而参数的类型为 ```int *```，显然类型不匹配。
>
> 第三种形式和第四种形式都是正确的，因为我们指定了指针数组的大小。
>
> 将数组 ```c``` 传递给 ```func3()``` 和 ```func4()``` 是正确的，但如果传入数组 ```d```  就会报错，因为数组的第二维不匹配。

Tips：

> 也就是说，在我们将数组作为参数传递给函数时，数组的第一维是可以省略的，但是剩下的维必须指定大小。
>
> 另外，一个常见的误区是：对于二维数组，我们传入一个指针的指针，对于三维数组，传递一个指针的指针的指针，这是不对的。

 

## 12. 指针和内存管理

### 12.1 内存架构

在一个典型的架构中，分配给应用程序的内存可以分为四个区段：

1. Test(Code)：用来存放需要执行的**指令**
2. Static/Global：用来存放**静态变量**或**全局变量**，也就是不在函数中声明的变量，它们的声明周期贯穿整个程序周期
3. Stack：用来存放**函数调用的所有信息**和**所有局部变量**，局部变量在函数内部声明
4. Heap：用来存放**动态分配**的变量

Tips:

1. **代码段，静态/全局数据段，栈区在运行期间的大小是不会增长的。**
2. 一个函数的帧栈大小，是在编译期间就决定了的。
3. 程序在任何时间，都是栈顶的函数在执行。



### 12.2 堆的引入

内存在栈上的分配和销毁有一定的规则，当一个函数被调用的时候，它被压入堆栈，结束时，弹出堆栈。如果变量是在栈上分配的，那你就不能操纵变量的范围。

另外一个限制，如果我们需要声明一个很大的数据类型，或者一个很大的数组作为局部变量，我们需要在编译期间知道数组的大小。如果我们有这样一个场景：需要在运行期间根据参数决定数组的大小，那么使用栈就会有问题了。

针对这些问题，比如分配很大的内存，或者把变量预留在内存中直到我们想用的时候为止，我们就有了堆。

### 12.3 堆简介和引应用

不像栈，应用程序的堆的大小是**不固定**的，它的大小在应用程序的整个声明周期是可变的，也没有特定的规则来分配和销毁特定的内存，程序员可以完全控制在堆上分配多少存在，数据保留到什么时候，你几乎可以任意使用堆上的内存，只要不超出系统自身的内存限制，但有时候随意使用堆也是危险的（内存泄露）

有时候我们把堆称为**内存的空闲池**，或者内存空闲存取区，我们可以在堆中获得我们想要的内存，尽管不同的操作系统对分配堆的方式不同，但可以把堆抽象看做一块很大的自由使用的内存空间

注意不要把这里的堆和数据结构中的堆混淆了，它们是完全不同的概念，这里的堆表示的只是空闲的内存池。另外栈区是栈的一种实现，而堆不是的。

使用堆内存意味着**动态内存分配**，在 C 或者 C++ 中使用堆的方法：

```
C：
    malloc();
    calloc();
    realloc();
    free();
C ++ :
	new;
    delete();
    C ++ 也可以使用 C 的四个函数，因为 C ++ 向后兼容 C
```

malloc会返回一个指向这块内存起始地址的**(void *)指针**，因此需要做类型转换，但是在 C ++ 里面则不需要，因此new 和 delete 操作符是**类型安全**的，这意味着，他们是带着类型的，返回指向特定类型的指针。

事实上**使用堆的唯一方式就是通过引用。**malloc函数所做的事情仅仅是，从堆上找到空闲的内存，为你预留空间然后通过指针返回给你，你去访问这块内存的方式就是自己维护一个指针。

分配在堆上的内存在函数调用结束之后并不会像栈上那样自动释放，因此，对于分配的内存，要注意回收（free） ，否则可能导致内存泄露

Code：C

```c
#include <stdio.h>
#include <stdlib.h>
int main()
{
    int a; // goes on stack
    int *p;
    p = (int *)malloc(sizeof(int));
    *p = 10;
    free(p);
    p = (int *)malloc(20 * sizeof(int));
    return 0;
}
```

Code：C++

```c++
#include <iostream>
#include <stdlib.h>
using namespace std;
int main()
{
    int a;              // 分配在栈上
    int *p;
    p = new int;
    *p = 10;            
    delete p;           // 释放空间
    p = new int[20];    // 分配一个数组
    delete[] p;         // 释放空间
    return 0;
}
```

### 12.4 库函数

介绍 C 语言支持中支持动态内存分配的各种库函数。

#### 12.4.1 malloc()

malloc 的全称是 **memory allocation**，中文叫**动态内存分配**，用于申请一块连续的指定大小的内存块区域以 void* 类型返回分配的内存区域地址，当无法知道内存具体位置的时候，想要绑定真正的内存空间，就需要用到动态的分配内存，且分配的大小就是程序要求的大小。 

如果分配成功则返回指向被分配内存的指针**(此空间中的初始值不确定)**，否则返回空指针 NULL。当内存不再使用时，应使用 free() 函数将内存块释放。

原型为：**void* malloc(size_t size);**

> 可以把 size_t看做 unsigned_int（>=0），显然我们不能指定一个负数。
>
> malloc 返回一个 void* 指针，这个指针指向分配给我们的内存块的第一个地址。
>
> size = 单元的数量 * 每个单元的字节数

例如：如果我们希望分配一个单元的 int 类型的空间

> ```void *p = malloc(4);``` 不是一种好的写法，因为变量的大小是由编译器决定的，尽管有时候 int 类型占四个字节是显然的。但也有可能有些编译器的 int 并不是 4 个字节。 
>
> 我们最好写成这样的形式：```void *p = malloc(sizeof(int));```

我们不可以解引用一个 void 指针，因此为了能够使用这块内存，我们需要把 malloc 返回的指针转成一个特定类型的指针。

malloc 之所以返回一个 void 指针是因为可以确保它的通用性，它做的仅仅只是分配内存，而不关心这块内存你是拿来存整形还是字符还是浮点数。

Code：

```c++
#include <iostream>
#include <stdlib.h>
using namespace std;
int main()
{
    int *p = (int *)malloc(3 * sizeof(int));
    // 通过指针操纵
    *p = 1;
    *(p + 1) = 2;
    *(p + 2) = 3;
    
    // 因为我们分配的是一个int数组，因此我们可以直接通过数组的方式操纵
    p[0] = 4;
    p[1] = 5;
    p[2] = 6;
    
    return 0;
}
```



#### 12.4.2 calloc()

使用 malloc 初始化时不会进行初始化，因此如果没有填入值得话，会得到一些随机值。但是使用 calloc 的话，会对其进行初始化为 0，如果分配成功则返回指向被分配内存的指针(**此空间中的初始值为 0 **)，否则返回空指针 NULL，

calloc 的全称是 **clear allocation**，中文名为**动态内存分配并清零**

函数原型为：**void *calloc(unsigned int num，unsigned int size);**

> num 表示分配的单元数量，size表示单元大小



#### 12.4.3 realloc()

如果你有一块内存，动态分配的内存，然后你想修改内存块的大小，就可以使用 realloc，realloc 的全称是 **reset allocation**，中文名为**动态内存调整**。

函数原型为：**extern void * realloc(void* mem_address, unsigned int newsize);**

> mem_address 指向已分配内存的起始地址的指针，如果 mem_address = NULL , 那么此时就相当于 malloc
>
> newsize 为新内存块的大小
>
> 先判断当前的指针是否有足够的连续空间，如果有，扩大 mem_address 指向的地址，并且将 mem_address 返回，如果空间不够，先按照 newsize 指定的大小分配空间，将原有数据从头到尾拷贝到新分配的内存区域，而后释放原来 mem_address 所指内存区域(**原来的指针会自动释放，不需要再使用 free**)，同时返回新分配的内存区域的首地址。重新分配成功返回指向被分配内存的指针，否则返回空指针 NULL。
>
> 注意：调整后的大小可大可小(如果新的大小大于原内存大小，新分配部分不会被初始化；如果新的大小小于原内存大小，可能会导致数据丢失）。



#### 12.4.4 free()

函数原型为：**void free(void *ptr);**

一般使用 malloc, calloc, realloc 函数进行内存分配后要使用 free(**起始地址的指针**) 对内存进行释放，不然内存申请过多会影响计算机的性能，以至于重启电脑。但是若使用动态内存分配函数后未使用 free 函数进行释放，还可以使用指针对该块内存进行访问，如果释放则不能再访问。

**注意：使用后该指针变量一定要重新指向 NULL，防止野指针出现，有效规避错误操作。**



#### 12.4.5 示例

上面函数的使用需要引入头文件 ```#include <stdlib.h>```

Code:

```c++
#include <iostream>
#include <cstdlib>
using namespace std;
int main()
{
    int n;  
    cout << "请输入数组的大小: " << endl;   
    cin >> n;
    
    // 编译错误,不能在运行时定义数组
    //int A[n]; 
    //正确方法
    int* A = (int*)malloc(n * sizeof(int));
    
    cout << "mallo分配的数组: " << endl;
    for(int i = 0; i < n; i ++ )    cout << A[i] << ' ';
    cout << endl;
    
    int *B = (int*)calloc(n, sizeof(int));
    cout << "callo分配的数组: " << endl;
    for(int i = 0; i < n; i ++ )    cout << B[i] << ' ';
    cout << endl;
    
    return 0;
}
```

Input && Output：

```
请输入数组的大小: 
25
mallo分配的数组: 
39855248 0 7365248 0 0 0 0 0 0 0 -1694498661 43847 39855248 0 7340368 0 0 -1 -1728053095 43846 39855248 0 7340368 0 0
callo分配的数组:
0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0
```

Explain：

> 在上面的代码中，我们实现了在程序运行过程当中分配一个数组，并且可以验证，malloc 不会进行初始化，因此我们得到一堆随机数，而 calloc 会进行0初始化，因此数组元素全为 0



*****



Code:

```c++
#include <iostream>
#include <cstdlib>
using namespace std;
int main()
{
    int n;  
    cout << "请输入数组的大小: " << endl;   
    cin >> n;
  
    int* A = (int*)malloc(n * sizeof(int));
    for(int i = 0; i < n; i ++ )    A[i] = i + 1;
    for(int i = 0; i < n; i ++ )    cout << A[i] << ' ';
    cout << endl;
    
    // 释放内存
    free(A);
    
    for(int i = 0; i < n; i ++ )    cout << A[i] << ' ';
    cout << endl;
    
    // free之后再次修改内存中的值
    for(int i = 0; i < n; i ++ )    A[i] = i + 1;
    for(int i = 0; i < n; i ++ )    cout << A[i] << ' ';
    cout << endl;
    
    return 0;
}
```

Input && Output：

````
请输入数组的大小: 
5
1 2 3 4 5 
16279024 0 16253264 0 5
1 2 3 4 5
````



Expalin：

> 可以发现，在释放掉动态分配的内存之后，仍然可以访问该内存，并打印出一些随机值(完全取决于编译器和机器)，甚至可以再次修改内存中的值并正常执行，但在其他的机器上这个程序可能会崩溃（可能另一个指针指向这块内存，而你修改了它）。
>
> 所以说 free 并不是真的 “销毁” 了一块内存，它只是说实现这个内存不属于你这个指针了。
>
> 这是使用指针的时候一个危险的地方。



****



Code：

```c++
#include <iostream>
#include <cstdlib>
using namespace std;
int main()
{
    int n;  
    cout << "请输入数组的大小: " << endl;   
    cin >> n;
  
    int* A = (int*)malloc(n * sizeof(int));
    
    cout << "请输入数组改编后的大小:" << endl;
    cin >> n;
    int *B = (int *)realloc(A, n * sizeof(int)); // 包含 free(A)
    for(int i = 0; i < n; i ++ ) B[i] = i + 1;
    for(int i = 0; i < n; i ++ )    cout << B[i] << ' ';
    cout << endl;
    
    free(B);
    
    return 0;
}
```



Input && Output：

```
请输入数组的大小: 
5
请输入数组改编后的大小:
10
1 2 3 4 5 6 7 8 9 10 
```



### 12.5 内存泄露

**所谓内存泄露，是指不当地使用动态内存或者内存的堆区，也就是在堆长增加"垃圾"**。其他语言诸如 Java 和 C# ，堆上的垃圾会被自动回收（垃圾回收机制）。

内存泄漏总是因为堆中未使用和未引用的内存块才发生的。

栈上的内存是自动回收的，栈的大小是固定的，会多就是会发生栈溢出。

常见的错误：在函数内部 malloc 一块内存，但是在函数结束时没有释放，如果这个函数执行非常多次，就造成内存泄漏。不要误以为在函数中 malloc 的内存会在函数结束时自动释放，函数结束时只会自动释放栈中的内存，而 malloc 是在堆上分配的内存，所以函数结束时不会释放。



## 13. 函数返回指针

**重点：什么时候可以从函数返回一个指针**

> 如果我们在堆上有一个内存地址或者在全局区有一个变量，那么我们就可以安全的返回他们的地址

Code：

```c++
#include <iostream>
#include <stdlib.h>

using namespace std;

// int* Add1(int *a, int *b)
// {
//     int c = (*a) + (*b);
//     return &c;
// }

int* Add(int *a, int *b)
{
    int *c = (int *)malloc(sizeof(int));
    *c = *a + *b;
    return c;
}

int main()
{
    int a = 2, b = 4;
    int* c = Add(&a, &b);
    //int *c = Add1(&a, &b); 报错
    cout << (*c) << endl;
    return 0;
}
```

Explain：

> 在上面的代码中，Add1函数并不是一个正确的函数返回指针的例子，因为它返回的是一个 《被调用的函数的中的局部变量的地址》，我们知道，一个函数的栈帧会随着函数的结束而被释放，所以当 Add1 函数结束的时候，局部变量 c 的地址就被释放了，所以说返回 c 的地址是错误的。
>
> 因此，**从函数返回地址时，我们需要小心它们的作用范围**
> 从栈底向上传一个局部变量或者局部变量的地址是可以的。
> 但是，从栈顶想下传一个局部变量或者局部变量的地址是不可以的。
>
> 因为被调函数的地址在主调函数的上面，当被调函数执行时，主调函数一定还没结束，而主调函数在执行时，被调函数分配的内存空间也一定被释放掉了。
>
> 正确的做法是返回全局变量取的地址或者堆区的地址，因为那里的地址不会被自动释放。



## 14. 函数指针



### 14.1 简介

根据定义可以知道，函数指针是用来保存函数的地址的指针。

那么问题来了，**函数的地址是什么？**

> 在内存中，一个函数就是一块连续的内存（里面是指令）
>
> **函数的地址，我们也把它称为函数的入口点，它是函数的第一条指令的地址（最低地址）**
>
> 通过直接使用函数名或者取地址可以得到函数的地址。
>
> ```function = &function```



### 14.2 函数指针的使用

对于下面这个函数：

```c++
int add(int a, int b) {
	return a + b;
}
```



函数指针的声明和初始化：

> 声明一个函数指针的步骤：
>
> 1. 首先输入的是，指向这个函数的返回类型，add 函数的返回类型是 int；
> 2. 然后跟一个括号，括号里面是 *name，name就是函数指针的名字；
> 3. 然后再跟一个括号，括号里面是所指向这个函数的所有参数的类型，要和所指向的这个函数的类型是一致的。
>
> 即：function_type (*pointer_name)(arguments_type);
>
> 声明一个指向 add 函数的指针 p：
>
> **--> int (*p)(int, int);	 // 声明了一个函数指针**
> **--> p = &add;				// 将函数指针 p 指向函数 add**
>
> 通过上面两条语句我们就实现了声明一个函数指针并让其指向一个函数，当然也可以写为一条语句。
>
> 调用函数指针：
>
> **--> int c = (*p)(2, 3); // 调用函数add**
>
> (*p)表示解引用，来获得这个函数，然后把两个参数传递给这个函数。
>
> 作为代替，我们也可以直接使用函数指针名（就像在使用函数名一样）：
>
> **-->int c = p(2, 3); 	 //  等价于上面的语句**



Code：

```c++
#include <iostream>
using namespace std;

int add(int a, int b) {
    return a + b;
}

void printStr() {
    printf("Hello,World!\n");
}

int main()
{
    int c;
    int (*p)(int, int) = &add;
    c = (*p)(2, 3);     
    cout << c << endl;  // 5
    c = p(4, 5);
    cout << c << endl;  // 9
    
    void (*p1)();
    p1 = printStr;
    p1();				// Hello,World!
    
    return 0;
}
```



### 14.3 使用案例（回调函数）

**回调函数：**一个函数引用传递给另一个函数时，那个函数被称作回调函数。

函数指针可以被用来做函数参数，接受函数指针的那个函数可以回调函数指针所指向的那个函数，举个例子：

Code：

```c
#include <stdio.h>
void A() {
    printf("Hello\n");
}
void B(void (*ptr)()) {
    (*ptr)();    // <==> ptr();
}
int main()
{
    void (*ptr)() = A;
    B(ptr);
    
    // <==>
    B(A);
}
```

Explain：

> 在上面的函数中，我们声明了两个函数 ```A``` 和 ```B```
> ```A``` 没有参数，返回值类型为 ```void```；
> ```B ```有一个参数，参数类型为一个返回值类型为 ```void```，没有参数的函数指针，返回值类型为 ```void```；
>
> 在 ```main```中，我们声明了一个返回值类型为 ```void```，没有参数的指针 ```ptr```，并让其指向函数 ```A```（类型匹配），返回将这个指针作为参数传递给函数 ```B```，函数 ```B``` 又通过函数指针 ```ptr``` 调用函数 ```A```。
>
> 函数 ```B``` 可以通过函数指针回调函数 ```A```
>
> **另外也可以写成 ```B(A)```的形式，因为函数的名字返回的就是指针。**





****





更清晰的例子：

Code：

```c++
void bubbleSort(int *a, int n) {
	for(int i = 0; i < n - 1; i ++ ) {
		for(int j = 0; j < n - 1 - i; j ++ ) {
            if(a[i] > a[i + 1]) {
                swap(a[i], a[i + 1])
            }
        }
    }
}
```

Explain：

> 通过上面的冒泡排序，我们可以实现对一个数组升序排序。现在有这样一种情况，我们有时候需要升序排序，有时候又需要降序排序。
>
> 最简单的方式就是写两份冒泡排序，然后修改判断条件，但是这样代码的冗余度太高。
>
> 另一种冗余度低且比较简单的方法是在函数中额外传递一个参数 ```flag``` ，用来标记这是升序排序还是降序排序。但这样的话如果 ```flag``` 很大的话，那么函数内部的 ```if``` 比较函数就会很多（我们需要判断依据何种判断条件）。
>
> 还有一种方式就是在函数中额外传递一个比较函数，这样就不要额外添加判断语句。

Code：

```c++
#include <iostream>
#include <algorithm>

using namespace std;

int cmp(int a, int b)
{
    if(a > b)   return -1;
    else    return 1;
}

void bubbleSort(int *a, int n, int (*compare)(int, int)) {
	for(int i = 0; i < n - 1; i ++ ) {
		for(int j = 0; j < n - 1 - i; j ++ ) {
            if(compare(a[j], a[j + 1]) > 0) {
                int tmp = a[j];
                a[j] = a[j + 1];
                a[j + 1] = tmp;
            }
        }
    }
}

int main()
{
    int arr[] = {3, 5, 1, 15, 9, 74, 5};
    int n = (int)sizeof(arr) / sizeof(arr[0]);
    bubbleSort(arr, n, cmp);
    for(int i = 0; i < n; i ++ )    cout << arr[i] << ' ';
    cout << endl;
    
    return 0;
}
```

Explain：

> 在 ```bubbleSort``` 函数中回调 ```cmp``` 函数实现自定义的排序方案。



























